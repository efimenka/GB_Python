#1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
#Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#Примеры матриц вы найдете в методичке.
#Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
#Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
#Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
class Matrix:
    def __init__(self, mat):
        self.mat = mat

    def __str__(self):
        for row in self.mat:
            for i in row:
                print(f"{i:5}", end="")
            print()
        return '\n'

    def __add__(self, other):
        for i in range(len(self.mat)):
            for i_2 in range(len(other.mat[i])):
                self.mat[i][i_2] = self.mat[i][i_2] + other.mat[i][i_2]
        return Matrix.__str__(self)


m = Matrix([[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]])
new_m = Matrix([[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]])
print(m.__add__(new_m))




#2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
#Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
#Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod


class Clothes(ABC):

    def __init__(self, a):
        self.a = a

    @property
    def cons(self):
        print(f'Ткань: {round(self.a / 6.5 + 0.5 + 2 * self.a + 0.3,2)}')

    @abstractmethod
    def abstract(self):
        return '!!!'


class Coat(Clothes):
    def cons(self):
        print(f'Пальто: {round(self.a / 6.5 + 0.5, 2)}')

    def abstract(self):
        return '!!!'


class Costume(Clothes):
    def cons(self):
        print(f'Костюм: {round(2 * self.a + 0.3, 2)}')

    def abstract(self):
        return '!!!'


coat = Coat(100)
costume = Costume(100)
coat.cons()
costume.cons()


#3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление значения до целого числа.
#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
#Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
#Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.

class Cell:
    def __init__(self, q):
        self.q = int(q)

    def __add__(self, other):
        print(f'Клетка: {self.q + other.q}')

    def __sub__(self, other):
        sub = self.q - other.q
        print(f'Клетка: {self.q - other.q}')

    def __truediv__(self, other):
        print(f'Клетка: {self.q//other.q}')

    def __mul__(self, other):
        print(f'Клетка: {self.q * other.q}')

    def order(self, row):
        result = ''
        for i in range(int(self.q / row)):
            result += '*' * row + '\n'
        result += '*' * (self.q % row) + '\n'
        print (result)


cell = Cell(111)
cell_2 = Cell(222)
cell + cell_2
cell - cell_2
cell / cell_2
cell * cell_2
cell.order(33)